<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Server Admin</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        button {
            padding: 5px 10px;
            cursor: pointer;
        }

        canvas {
            border: 1px solid #000;
            max-width: 400px;
        }
    </style>
</head>

<body>
    <h1>Browser Sessions</h1>
    <button onclick="createSession()">Create New Session</button>

    <table id="sessionsTable">
        <thead>
            <tr>
                <th>ID</th>
                <th>Created At</th>
                <th>Expires At</th>
                <th>Actions</th>
                <th>Preview (WebRTC)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script>
        const peerConnections = {};

        async function loadSessions() {
            const res = await fetch('/sessions');
            const sessions = await res.json();
            const tbody = document.querySelector('#sessionsTable tbody');
            tbody.innerHTML = '';

            sessions.forEach(s => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${s.id}</td>
                    <td>${new Date(s.created_at).toLocaleString()}</td>
                    <td>${new Date(s.expires_at).toLocaleString()}</td>
                    <td>
                        <button onclick="stopSession('${s.id}')">Stop</button>
                        <a href="${s.cdp_url}" target="_blank">CDP URL</a>
                    </td>
                    <td>
                        <canvas id="canvas-${s.id}" width="1280" height="720"></canvas>
                        <br>
                        <button onclick="startWebRTC('${s.id}')">Start Stream</button>
                    </td>
                `;
                tbody.appendChild(tr);
                
                // Auto-start WebRTC
                startWebRTC(s.id);
            });
        }

        async function createSession() {
            await fetch('/sessions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ duration_minutes: 10 })
            });
            loadSessions();
        }

        async function stopSession(id) {
            await fetch(`/sessions/${id}`, { method: 'DELETE' });
            if (peerConnections[id]) {
                peerConnections[id].close();
                delete peerConnections[id];
            }
            loadSessions();
        }

        async function startWebRTC(sessionId) {
            console.log('Starting WebRTC for session:', sessionId);
            if (peerConnections[sessionId]) {
                console.log('Peer connection already exists');
                return;
            }

            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            peerConnections[sessionId] = pc;

            // Create Data Channel (Client initiates)
            const dc = pc.createDataChannel('screencast');
            dc.onopen = () => console.log('Data channel opened');
            dc.onmessage = (e) => {
                if (typeof e.data === 'string') {
                    const msg = JSON.parse(e.data);
                    if (msg.type === 'frame-start') {
                        window.currentFrame = {
                            totalSize: msg.size,
                            receivedSize: 0,
                            buffer: new Uint8Array(msg.size),
                            data: []
                        };
                    }
                } else {
                    // Binary chunk
                    if (!window.currentFrame) return;

                    const chunk = new Uint8Array(e.data);
                    window.currentFrame.buffer.set(chunk, window.currentFrame.receivedSize);
                    window.currentFrame.receivedSize += chunk.length;

                    if (window.currentFrame.receivedSize >= window.currentFrame.totalSize) {
                        // Frame complete
                        const blob = new Blob([window.currentFrame.buffer], { type: 'image/jpeg' });
                        const url = URL.createObjectURL(blob);
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.getElementById(`canvas-${sessionId}`);
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            }
                            URL.revokeObjectURL(url);
                        };
                        img.src = url;
                        window.currentFrame = null; // Reset
                    }
                }
            };

            pc.oniceconnectionstatechange = () => console.log('ICE State:', pc.iceConnectionState);
            pc.onicegatheringstatechange = () => console.log('ICE Gathering State:', pc.iceGatheringState);
            pc.onsignalingstatechange = () => console.log('Signaling State:', pc.signalingState);

            // Create offer
            console.log('Creating offer...');
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            // Wait for ICE gathering to complete
            console.log('Waiting for ICE gathering...');
            await new Promise(resolve => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    const checkState = () => {
                        if (pc.iceGatheringState === 'complete') {
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            resolve();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', checkState);

                    // Timeout after 2 seconds to send whatever we have
                    setTimeout(() => {
                        console.log('ICE gathering timed out, proceeding with gathered candidates');
                        pc.removeEventListener('icegatheringstatechange', checkState);
                        resolve();
                    }, 2000);
                }
            });
            console.log('ICE gathering complete');

            // Send offer to server
            console.log('Sending offer to server...');
            const res = await fetch(`/sessions/${sessionId}/webrtc/offer`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(pc.localDescription)
            });

            if (!res.ok) {
                console.error('Failed to start WebRTC session:', res.statusText);
                alert('Failed to start WebRTC session');
                return;
            }

            const answer = await res.json();
            console.log('Received answer:', answer);
            await pc.setRemoteDescription(answer);

            // Handle Data Channel (Deprecated: Client initiates now)
            // pc.ondatachannel = (event) => { ... }
        }

        // Auto-refresh every 10 seconds (less frequent to avoid resetting UI)
        // setInterval(loadSessions, 10000);
        loadSessions();
    </script>
</body>

</html>