<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Server Admin</title>
    <style>
        body {
            font-family: sans-serif;
            padding: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        button {
            padding: 5px 10px;
            cursor: pointer;
        }

        canvas {
            border: 1px solid #000;
            max-width: 400px;
        }
    </style>
</head>

<body>
    <h1>Browser Sessions</h1>
    <button onclick="createSession()">Create New Session</button>

    <table id="sessionsTable">
        <thead>
            <tr>
                <th>ID</th>
                <th>Created At</th>
                <th>Expires At</th>
                <th>Actions</th>
                <th>Preview (WHIP)</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <script>
        const peerConnections = {};

        async function loadSessions() {
            const res = await fetch('/sessions');
            const sessions = await res.json();
            const tbody = document.querySelector('#sessionsTable tbody');
            tbody.innerHTML = '';

            sessions.forEach(s => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${s.id}</td>
                    <td>${new Date(s.created_at).toLocaleString()}</td>
                    <td>${new Date(s.expires_at).toLocaleString()}</td>
                    <td>
                        <button onclick="stopSession('${s.id}')">Stop</button>
                        <a href="${s.cdp_url}" target="_blank">CDP URL</a>
                    </td>
                    <td>
                        <canvas id="canvas-${s.id}" width="1280" height="720"></canvas>
                        <br>
                        <button onclick="startWebRTC('${s.id}')">Start Stream</button>
                    </td>
                `;
                tbody.appendChild(tr);
                
                // Auto-start WebRTC
                startWebRTC(s.id);
            });
        }

        async function createSession() {
            await fetch('/sessions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ duration_minutes: 10 })
            });
            loadSessions();
        }

        async function stopSession(id) {
            // Terminate WHIP session if active (per WHIP protocol)
            if (window.whipResources && window.whipResources[id]) {
                try {
                    await fetch(window.whipResources[id], { method: 'DELETE' });
                    console.log('WHIP: Terminated resource:', window.whipResources[id]);
                    delete window.whipResources[id];
                } catch (err) {
                    console.error('WHIP: Failed to terminate resource:', err);
                }
            }
            
            // Close peer connection
            if (peerConnections[id]) {
                peerConnections[id].close();
                delete peerConnections[id];
            }
            
            // Delete browser session
            await fetch(`/sessions/${id}`, { method: 'DELETE' });
            loadSessions();
        }

        async function startWebRTC(sessionId) {
            console.log('Starting WHIP session for:', sessionId);
            if (peerConnections[sessionId]) {
                console.log('Peer connection already exists');
                return;
            }

            const pc = new RTCPeerConnection({
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            });
            peerConnections[sessionId] = pc;

            // Create Data Channel (Client initiates)
            const dc = pc.createDataChannel('screencast');
            dc.onopen = () => console.log('WHIP: Data channel opened');
            dc.onmessage = (e) => {
                if (typeof e.data === 'string') {
                    const msg = JSON.parse(e.data);
                    if (msg.type === 'frame-start') {
                        window.currentFrame = {
                            totalSize: msg.size,
                            receivedSize: 0,
                            buffer: new Uint8Array(msg.size),
                            data: []
                        };
                    }
                } else {
                    // Binary chunk
                    if (!window.currentFrame) return;

                    const chunk = new Uint8Array(e.data);
                    window.currentFrame.buffer.set(chunk, window.currentFrame.receivedSize);
                    window.currentFrame.receivedSize += chunk.length;

                    if (window.currentFrame.receivedSize >= window.currentFrame.totalSize) {
                        // Frame complete
                        const blob = new Blob([window.currentFrame.buffer], { type: 'image/jpeg' });
                        const url = URL.createObjectURL(blob);
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.getElementById(`canvas-${sessionId}`);
                            if (canvas) {
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                            }
                            URL.revokeObjectURL(url);
                        };
                        img.src = url;
                        window.currentFrame = null; // Reset
                    }
                }
            };

            pc.oniceconnectionstatechange = () => console.log('WHIP: ICE State:', pc.iceConnectionState);
            pc.onicegatheringstatechange = () => console.log('WHIP: ICE Gathering State:', pc.iceGatheringState);
            pc.onsignalingstatechange = () => console.log('WHIP: Signaling State:', pc.signalingState);

            // Create offer (WHIP client sends SDP offer)
            console.log('WHIP: Creating offer...');
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            // Wait for ICE gathering to complete
            console.log('WHIP: Waiting for ICE gathering...');
            await new Promise(resolve => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                } else {
                    const checkState = () => {
                        if (pc.iceGatheringState === 'complete') {
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            resolve();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', checkState);

                    // Timeout after 2 seconds to send whatever we have
                    setTimeout(() => {
                        console.log('WHIP: ICE gathering timed out, proceeding with gathered candidates');
                        pc.removeEventListener('icegatheringstatechange', checkState);
                        resolve();
                    }, 2000);
                }
            });
            console.log('WHIP: ICE gathering complete');

            // WHIP Protocol: POST SDP offer with Content-Type: application/sdp
            console.log('WHIP: Sending SDP offer to WHIP endpoint...');
            const res = await fetch(`/sessions/${sessionId}/whip`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/sdp' },
                body: pc.localDescription.sdp
            });

            if (!res.ok) {
                console.error('WHIP: Failed to start session:', res.statusText);
                alert('Failed to start WHIP session');
                return;
            }

            // WHIP Protocol: Server responds with 201 Created and SDP answer
            // Location header contains the resource URL for future PATCH/DELETE
            const resourceLocation = res.headers.get('Location');
            console.log('WHIP: Resource created at:', resourceLocation);
            
            // Store resource location for cleanup
            if (!window.whipResources) window.whipResources = {};
            window.whipResources[sessionId] = resourceLocation;

            const answerSDP = await res.text();
            const answer = {
                type: 'answer',
                sdp: answerSDP
            };
            console.log('WHIP: Received SDP answer');
            await pc.setRemoteDescription(answer);
        }

        // Auto-refresh every 10 seconds (less frequent to avoid resetting UI)
        // setInterval(loadSessions, 10000);
        loadSessions();
    </script>
</body>

</html>